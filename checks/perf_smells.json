[
  {
    "id": "perf-001",
    "type": "n-plus-one",
    "severity": "high",
    "file": "frontend/src/handlers/realtimeHandlers.ts",
    "line": 142,
    "snippet": "for (const update of updates) {\n  this.cacheCoordinator.optimisticUpdate([...], ...)\n}",
    "description": "processBulkUpdate iterates over N items and triggers individual cache operations for each. Results in N cache updates + N re-renders.",
    "impact": "For 100-item batch: ~2-5 seconds processing time, UI freezes",
    "suggestion": "Batch all cache updates, suspend queries during batch, single invalidation after completion",
    "estimated_improvement": "10-50x faster (2-5s -> 50-100ms)",
    "references": ["checks/bug_report.md#6"]
  },
  {
    "id": "perf-002",
    "type": "repeated-json-parse",
    "severity": "medium",
    "file": "frontend/src/hooks/useWebSocket.ts",
    "line": null,
    "snippet": "Inferred from WebSocket message handler pattern",
    "description": "If WebSocket onMessage handler parses JSON, then passes to validator that re-parses, results in double JSON.parse",
    "impact": "For 200 msgs/sec: ~200ms extra CPU time per second",
    "suggestion": "Parse once in validator: parseWebSocketData(data: string) does single JSON.parse + validate",
    "estimated_improvement": "2x faster message processing (2ms -> 1ms)",
    "references": ["frontend/src/types/ws_messages.ts:193"]
  },
  {
    "id": "perf-003",
    "type": "unbounded-map-growth",
    "severity": "medium",
    "file": "frontend/src/types/ws_messages.ts",
    "line": 368,
    "snippet": "private recentMessages = new Map<string, number>();",
    "description": "MessageDeduplicator.recentMessages map grows unbounded during idle periods. cleanup() only runs on new message arrival.",
    "impact": "Long-running sessions: 10-100MB memory leak over 8 hours",
    "suggestion": "Add setInterval cleanup timer every windowMs",
    "estimated_improvement": "Bounded memory usage (constant ~1MB regardless of session duration)",
    "references": ["checks/bug_report.md#4"]
  },
  {
    "id": "perf-004",
    "type": "per-message-allocation",
    "severity": "low",
    "file": "frontend/src/types/ws_messages.ts",
    "line": 381,
    "snippet": "const key = this.getMessageKey(message);",
    "description": "getMessageKey allocates new string for every message. For high-throughput scenarios (>1000 msgs/sec), allocation overhead adds up.",
    "impact": "Minimal (~0.1ms per message) but measurable at scale",
    "suggestion": "Consider object pooling or WeakMap for message keys",
    "estimated_improvement": "10-20% faster at >1000 msgs/sec",
    "references": []
  },
  {
    "id": "perf-005",
    "type": "quadratic-loop",
    "severity": "high",
    "file": "frontend/src/layers/types/layer-types.ts",
    "line": null,
    "snippet": "Inferred from layer processing patterns",
    "description": "If layer update loops over features, and each feature loops over affected filters to check applicability, results in O(features * filters) complexity.",
    "impact": "1000 features * 10 filters = 10,000 iterations per update",
    "suggestion": "Precompute filter applicability once, store in Map, O(1) lookups",
    "estimated_improvement": "100-1000x faster for large datasets",
    "references": []
  },
  {
    "id": "perf-006",
    "type": "blocking-validation",
    "severity": "medium",
    "file": "frontend/src/types/ws_messages.ts",
    "line": 168,
    "snippet": "const result = RealtimeMessageSchema.safeParse(data);",
    "description": "Zod validation is synchronous and blocks event loop. For complex schemas (nested GeoJSON), can take 1-3ms per message.",
    "impact": "At 200 msgs/sec: 200-600ms CPU blocking per second",
    "suggestion": "Skip validation in production, or use async validation with Web Workers for large payloads",
    "estimated_improvement": "0ms overhead in production",
    "references": ["checks/bug_report.md#10"]
  },
  {
    "id": "perf-007",
    "type": "excessive-invalidation",
    "severity": "medium",
    "file": "frontend/src/handlers/realtimeHandlers.ts",
    "line": 112,
    "snippet": "this.queryClient.invalidateQueries({\n  queryKey: hierarchyKeys.all,\n  exact: false\n});",
    "description": "processHierarchyChange invalidates ALL hierarchy queries with exact: false. Over-invalidation causes unnecessary refetches.",
    "impact": "Refetches all root, children, breadcrumbs queries even if unaffected",
    "suggestion": "Only invalidate specific affected paths, not entire hierarchy",
    "estimated_improvement": "5-10x fewer network requests",
    "references": []
  },
  {
    "id": "perf-008",
    "type": "synchronous-cache-update",
    "severity": "low",
    "file": "frontend/src/handlers/realtimeHandlers.ts",
    "line": 53,
    "snippet": "const updateResult = this.cacheCoordinator.optimisticUpdate(...)",
    "description": "optimisticUpdate is synchronous, blocks message processing. For large cache entries (1000+ items), can take 5-10ms.",
    "impact": "Message processing latency increases with cache size",
    "suggestion": "Use queueMicrotask or requestIdleCallback for non-critical cache updates",
    "estimated_improvement": "Message processing latency constant regardless of cache size",
    "references": []
  },
  {
    "id": "perf-009",
    "type": "duplicate-bbox-calculation",
    "severity": "low",
    "file": "frontend/src/layers/implementations/PolygonLayer.ts",
    "line": null,
    "snippet": "Inferred from polygon processing",
    "description": "If bbox calculated per-render instead of cached on geometry change, wastes CPU on unchanged polygons.",
    "impact": "Minimal for <1000 polygons, noticeable at 10k+",
    "suggestion": "Cache bbox in properties, only recalculate on geometry change",
    "estimated_improvement": "10-20% faster renders for large polygon datasets",
    "references": []
  },
  {
    "id": "perf-010",
    "type": "unindexed-entity-lookup",
    "severity": "medium",
    "file": "frontend/src/handlers/realtimeHandlers.ts",
    "line": 72,
    "snippet": "const updatedEntities = current.entities.map((e: Entity) =>\n  e.id === targetEntity.id ? { ...e, ...targetEntity } : e\n);",
    "description": "Linear search through entities array for every update. O(n) lookup per message.",
    "impact": "For 1000 entities: 1000 comparisons per update",
    "suggestion": "Use Map<id, Entity> for O(1) lookups, convert to array only for React",
    "estimated_improvement": "100x faster for large entity lists",
    "references": []
  },
  {
    "id": "perf-011",
    "type": "redundant-spread-operator",
    "severity": "low",
    "file": "frontend/src/handlers/realtimeHandlers.ts",
    "line": 55,
    "snippet": "(current: Entity | undefined) => current ? { ...current, ...targetEntity } : targetEntity",
    "description": "Spread operator creates shallow copy of entire object. For entities with large metadata, copies unnecessary properties.",
    "impact": "Minimal (<0.1ms) but adds up with high message rate",
    "suggestion": "Use Object.assign or only spread changed properties",
    "estimated_improvement": "5-10% faster for large entities",
    "references": []
  },
  {
    "id": "perf-012",
    "type": "missing-memo",
    "severity": "medium",
    "file": "Inferred from React component patterns",
    "line": null,
    "snippet": "N/A - static analysis inferred",
    "description": "If layer components don't use React.memo or useMemo for expensive computations (e.g., GeoJSON processing), re-renders trigger unnecessary work.",
    "impact": "Every parent re-render triggers full layer reprocessing",
    "suggestion": "Wrap layer components in React.memo, memoize GeoJSON processing with useMemo",
    "estimated_improvement": "50-80% fewer re-renders",
    "references": ["frontend/src/layers/implementations/"]
  }
]
