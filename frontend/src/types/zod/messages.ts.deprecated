/**
 * DEPRECATED: This file is deprecated in favor of the unified schema.
 *
 * Please import from '../ws_messages' instead.
 * This file exists only for backward compatibility.
 *
 * All WebSocket message schemas have been consolidated into:
 * /frontend/src/types/ws_messages.ts (SINGLE SOURCE OF TRUTH)
 */

import { z } from 'zod';
import { EntitySchema, EntityIdSchema, TimestampSchema } from './entities';

// Re-export from unified schema
export * from '../ws_messages';

/**
 * Base WebSocket message schema
 */
export const WebSocketMessageSchema = z.object({
  type: z.string(),
  data: z.unknown().optional(),
  error: z.string().optional(),
  channels: z.array(z.string()).optional(),
  timestamp: TimestampSchema.optional(),
});

export type WebSocketMessageFromSchema = z.infer<typeof WebSocketMessageSchema>;

/**
 * Message type enum
 */
export const MessageTypeSchema = z.enum([
  'ping',
  'pong',
  'subscribe',
  'unsubscribe',
  'entity_update',
  'hierarchy_change',
  'bulk_update',
  'cache_invalidate',
  'search_update',
  'layer_data_update',
  'gpu_filter_sync',
  'serialization_error',
  'processing_error',
]);

export type MessageTypeFromSchema = z.infer<typeof MessageTypeSchema>;

/**
 * Ping message (keepalive)
 */
export const PingMessageSchema = z.object({
  type: z.literal('ping'),
  timestamp: TimestampSchema.optional(),
});

/**
 * Pong message (keepalive response)
 */
export const PongMessageSchema = z.object({
  type: z.literal('pong'),
  timestamp: TimestampSchema.optional(),
});

/**
 * Subscribe message
 */
export const SubscribeMessageSchema = z.object({
  type: z.literal('subscribe'),
  channels: z.array(z.string()).min(1, 'Must subscribe to at least one channel'),
});

/**
 * Unsubscribe message
 */
export const UnsubscribeMessageSchema = z.object({
  type: z.literal('unsubscribe'),
  channels: z.array(z.string()).min(1, 'Must unsubscribe from at least one channel'),
});

/**
 * Entity update message
 */
export const EntityUpdateMessageSchema = z.object({
  type: z.literal('entity_update'),
  data: EntitySchema.optional(),
  entityId: EntityIdSchema.optional(),
  timestamp: TimestampSchema.optional(),
}).refine(
  (msg) => msg.data !== undefined || msg.entityId !== undefined,
  {
    message: 'Either data or entityId must be provided',
  }
);

export type EntityUpdateMessageFromSchema = z.infer<typeof EntityUpdateMessageSchema>;

/**
 * Hierarchy change message
 */
export const HierarchyChangeMessageSchema = z.object({
  type: z.literal('hierarchy_change'),
  data: z.object({
    preloadRoots: z.array(z.string()).optional(),
  }).optional(),
  timestamp: TimestampSchema.optional(),
});

export type HierarchyChangeMessageFromSchema = z.infer<typeof HierarchyChangeMessageSchema>;

/**
 * Bulk update message
 */
export const BulkUpdateMessageSchema = z.object({
  type: z.literal('bulk_update'),
  data: z.object({
    updates: z.array(WebSocketMessageSchema),
  }),
  timestamp: TimestampSchema.optional(),
});

export type BulkUpdateMessageFromSchema = z.infer<typeof BulkUpdateMessageSchema>;

/**
 * Cache invalidate message
 */
export const CacheInvalidateMessageSchema = z.object({
  type: z.literal('cache_invalidate'),
  data: z.object({
    queryKeys: z.array(z.unknown()).optional(),
    invalidateAll: z.boolean().optional(),
  }).optional(),
  timestamp: TimestampSchema.optional(),
});

export type CacheInvalidateMessageFromSchema = z.infer<typeof CacheInvalidateMessageSchema>;

/**
 * Search update message
 */
export const SearchUpdateMessageSchema = z.object({
  type: z.literal('search_update'),
  data: z.object({
    query: z.string(),
    results: z.array(EntitySchema),
  }),
  timestamp: TimestampSchema.optional(),
});

export type SearchUpdateMessageFromSchema = z.infer<typeof SearchUpdateMessageSchema>;

/**
 * Layer data update message
 */
export const LayerDataUpdateMessageSchema = z.object({
  type: z.literal('layer_data_update'),
  data: z.object({
    layer_id: z.string(),
    layer_type: z.string(),
    layer_data: z.unknown(),
    bbox: z.object({
      minLat: z.number(),
      maxLat: z.number(),
      minLng: z.number(),
      maxLng: z.number(),
    }).optional(),
  }),
  timestamp: TimestampSchema.optional(),
});

export type LayerDataUpdateMessageFromSchema = z.infer<typeof LayerDataUpdateMessageSchema>;

/**
 * GPU filter sync message
 */
export const GPUFilterSyncMessageSchema = z.object({
  type: z.literal('gpu_filter_sync'),
  data: z.object({
    filter_id: z.string(),
    filter_type: z.string(),
    filter_params: z.record(z.unknown()),
    affected_layers: z.array(z.string()),
    status: z.enum(['applied', 'pending', 'error', 'cleared']),
  }),
  timestamp: TimestampSchema.optional(),
});

export type GPUFilterSyncMessageFromSchema = z.infer<typeof GPUFilterSyncMessageSchema>;

/**
 * Serialization error message
 */
export const SerializationErrorMessageSchema = z.object({
  type: z.literal('serialization_error'),
  error: z.string(),
  timestamp: TimestampSchema.optional(),
});

/**
 * Processing error message
 */
export const ProcessingErrorMessageSchema = z.object({
  type: z.literal('processing_error'),
  error: z.string(),
  originalMessage: WebSocketMessageSchema.optional(),
  timestamp: TimestampSchema.optional(),
});

/**
 * Union of all message schemas (discriminated by type)
 */
export const AnyWebSocketMessageSchema = z.discriminatedUnion('type', [
  PingMessageSchema,
  PongMessageSchema,
  SubscribeMessageSchema,
  UnsubscribeMessageSchema,
  EntityUpdateMessageSchema,
  HierarchyChangeMessageSchema,
  BulkUpdateMessageSchema,
  CacheInvalidateMessageSchema,
  SearchUpdateMessageSchema,
  LayerDataUpdateMessageSchema,
  GPUFilterSyncMessageSchema,
  SerializationErrorMessageSchema,
  ProcessingErrorMessageSchema,
]);

export type AnyWebSocketMessageFromSchema = z.infer<typeof AnyWebSocketMessageSchema>;

/**
 * Helper: Get message schema by type
 */
export function getMessageSchemaByType(type: string): z.ZodSchema {
  const schemaMap: Record<string, z.ZodSchema> = {
    ping: PingMessageSchema,
    pong: PongMessageSchema,
    subscribe: SubscribeMessageSchema,
    unsubscribe: UnsubscribeMessageSchema,
    entity_update: EntityUpdateMessageSchema,
    hierarchy_change: HierarchyChangeMessageSchema,
    bulk_update: BulkUpdateMessageSchema,
    cache_invalidate: CacheInvalidateMessageSchema,
    search_update: SearchUpdateMessageSchema,
    layer_data_update: LayerDataUpdateMessageSchema,
    gpu_filter_sync: GPUFilterSyncMessageSchema,
    serialization_error: SerializationErrorMessageSchema,
    processing_error: ProcessingErrorMessageSchema,
  };
  return schemaMap[type] || WebSocketMessageSchema;
}

/**
 * Message ID for idempotency tracking
 */
export const MessageIdSchema = z.string().min(1);

/**
 * Idempotent message wrapper
 */
export const IdempotentMessageSchema = z.object({
  messageId: MessageIdSchema,
  message: AnyWebSocketMessageSchema,
  sentAt: TimestampSchema,
});

export type IdempotentMessageFromSchema = z.infer<typeof IdempotentMessageSchema>;
